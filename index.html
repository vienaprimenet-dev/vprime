<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Mapa Interativo Avançado - Leaflet</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-draw/dist/leaflet.draw.css"/>
<style>
  #map { height: 100vh; }
  .filter-box {
    position: absolute;
    top: 10px;
    left: 50px;
    z-index: 1000;
    background: white;
    padding: 8px;
    border-radius: 5px;
    font-family: Arial, sans-serif;
    box-shadow: 0px 2px 6px rgba(0,0,0,0.3);
  }
  .filter-box button { margin-left: 5px; }
</style>
</head>
<body>

<div class="filter-box">
  <label>Filtrar por tipo:</label>
  <select id="filter">
    <option value="Todos">Todos</option>
    <option value="Cliente VIP">Cliente VIP</option>
    <option value="Cliente Regular">Cliente Regular</option>
  </select>
  <button id="btnLimpar">Limpar tudo</button>
  <button id="btnExport">Exportar CSV</button>
  <span id="count"></span>
  <span id="distances"></span>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw/dist/leaflet.draw.js"></script>
<script src="https://unpkg.com/papaparse@5.3.0/papaparse.min.js"></script>

<script>
const SHEET_ID = "1_fuH8vWVLWqYb3H3PD6OB7iNuq_gT_s5wOEb01POuaw"; // ID da planilha Google Sheets
const SHEET_URL = `https://docs.google.com/spreadsheets/d/1_fuH8vWVLWqYb3H3PD6OB7iNuq_gT_s5wOEb01POuaw/gviz/tq?tqx=out:csv`;

const map = L.map('map').setView([-23.55052, -46.633308], 5);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
}).addTo(map);

let markers = [];
let markerGroup = L.featureGroup().addTo(map);
let currentCircle = null;

// Medições de distância
let measurementLayer = L.featureGroup().addTo(map);
let measurementPoints = [];
let distances = [];

// Carregar dados da planilha
function loadData(filter = "Todos") {
    markerGroup.clearLayers();
    markers = [];

    Papa.parse(SHEET_URL, {
        download: true,
        header: true,
        complete: function(results) {
            results.data.forEach(row => {
                if (row.Latitude && row.Longitude) {
                    if (filter !== "Todos" && row.InfoExtra !== filter) return;

                    const marker = L.marker([parseFloat(row.Latitude), parseFloat(row.Longitude)], {data: row, selected:false})
                        .bindPopup(`<b>${row.Nome}</b><br>${row.InfoExtra}`)
                        .bindTooltip(row.Nome, {permanent:false, direction:"top"});
                    markerGroup.addLayer(marker);
                    markers.push(marker);
                }
            });
            updateCircleSelection();
        }
    });
}

// Atualiza contagem e tooltip do círculo
function updateCircleSelection() {
    if (!currentCircle) {
        document.getElementById("count").innerText = ` | Pontos: ${markers.length}`;
        return;
    }
    const center = currentCircle.getLatLng();
    const radius = currentCircle.getRadius();
    const selecionados = markers.filter(m => center.distanceTo(m.getLatLng()) <= radius);
    
    // Atualiza seleção e cor
    markers.forEach(m => {
        if (selecionados.includes(m)) {
            m.selected = true;
            m.setIcon(L.icon({iconUrl:'https://maps.google.com/mapfiles/ms/icons/green-dot.png', iconSize:[32,32]}));
        } else {
            m.selected = false;
            m.setIcon(new L.Icon.Default());
        }
    });

    // Atualiza tooltip do círculo
    const nomes = selecionados.map(m => m.options.data.Nome).join(", ");
    currentCircle.bindTooltip(`Pontos no raio: ${selecionados.length}<br>${nomes}`, {permanent:true}).openTooltip();

    // Ajusta zoom para englobar pontos selecionados
    if(selecionados.length > 0){
        const group = L.featureGroup(selecionados);
        map.fitBounds(group.getBounds().pad(0.2));
    }

    document.getElementById("count").innerText = ` | Pontos no raio: ${selecionados.length}`;
}

// Função para baixar CSV
function downloadCSV(data) {
    if(data.length === 0) return alert("Nenhum ponto selecionado!");
    const csvContent = "data:text/csv;charset=utf-8," + 
        data.map(e => Object.values(e.data).join(",")).join("\n");
    const link = document.createElement("a");
    link.setAttribute("href", encodeURI(csvContent));
    link.setAttribute("download", "pontos_selecionados.csv");
    document.body.appendChild(link);
    link.click();
}

// Botão limpar tudo
document.getElementById("btnLimpar").addEventListener("click", ()=>{
    if(currentCircle){ map.removeLayer(currentCircle); currentCircle=null; }
    markerGroup.eachLayer(m => m.setIcon(new L.Icon.Default()));
    measurementLayer.clearLayers();
    measurementPoints = [];
    distances = [];
    document.getElementById("distances").innerText = "";
    updateCircleSelection();
});

// Botão exportar CSV
document.getElementById("btnExport").addEventListener("click", ()=>{
    if(!currentCircle) return alert("Desenhe um raio primeiro!");
    const center = currentCircle.getLatLng();
    const radius = currentCircle.getRadius();
    const selecionados = markers.filter(m => center.distanceTo(m.getLatLng()) <= radius);
    downloadCSV(selecionados);
});

// Controle de desenho
const drawControl = new L.Control.Draw({
    draw: {
        marker:false, polygon:false, polyline:false, rectangle:false, circle:true, circlemarker:false
    },
    edit: { featureGroup: new L.FeatureGroup().addTo(map) }
});
map.addControl(drawControl);

// Evento ao criar círculo
map.on(L.Draw.Event.CREATED, function(e) {
    if(currentCircle) map.removeLayer(currentCircle);
    currentCircle = e.layer;
    currentCircle.addTo(map);
    currentCircle.on('edit', updateCircleSelection);
    updateCircleSelection();
});

// Evento de filtro
document.getElementById("filter").addEventListener("change", function() {
    loadData(this.value);
});

// Carrega dados inicialmente
loadData();

// Medição de distância entre pontos clicados
map.on('click', function(e){
    measurementPoints.push(e.latlng);
    if(measurementPoints.length > 1){
        const last = measurementPoints[measurementPoints.length-1];
        const prev = measurementPoints[measurementPoints.length-2];
        const line = L.polyline([prev,last], {color:'blue'}).addTo(measurementLayer);
        const dist = prev.distanceTo(last)/1000; // km
        distances.push(dist.toFixed(2));
        document.getElementById("distances").innerText = ` | Distâncias (km): ${distances.join(", ")}`;
    }
});
</script>

</body>
</html>
